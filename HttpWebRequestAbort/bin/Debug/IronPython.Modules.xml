<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IronPython.Modules</name>
    </assembly>
    <members>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.BZ2Compressor.GetLatestData">
            <summary>
            Copy the latest data from the memory buffer.
            
            This won't always contain data, because comrpessed data is only written after a block is filled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.BZ2Decompressor.AddData(System.Byte[])">
            <summary>
            Add data to the input buffer. This manipulates the position of the stream
            to make it appear to the BZip2 stream that nothing has actually changed.
            </summary>
            <param name="bytes">The data to append to the buffer.</param>
        </member>
        <member name="M:IronPython.Modules.Bz2.Bz2Module.ToArrayNoCopy(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Try to convert IList(Of byte) to byte[] without copying, if possible.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Modules.PythonCopyReg.EnsureCallable(IronPython.Runtime.CodeContext,System.Object,System.String)">
            <summary>
            Throw TypeError with a specified message if object isn't callable.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCopyReg.GetCode(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Convert object to ushort, throwing ValueError on overflow.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonPickle.FileInput">
            <summary>
            Interface for "file-like objects" that implement the protocol needed by load() and friends.
            This enables the creation of thin wrappers that make fast .NET types and slow Python types look the same.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonPickle.FileOutput">
            <summary>
            Interface for "file-like objects" that implement the protocol needed by dump() and friends.
            This enables the creation of thin wrappers that make fast .NET types and slow Python types look the same.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.SaveObject(IronPython.Modules.PythonPickle.PicklerObject,IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Call the appropriate reduce method for obj and pickle the object using
            the resulting data. Use the first available of
            copy_reg.dispatch_table[type(obj)], obj.__reduce_ex__, and obj.__reduce__.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.SaveReduce(IronPython.Runtime.CodeContext,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Pickle the result of a reduce function.
            
            Only context, obj, func, and reduceCallable are required; all other arguments may be null.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteFloatAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteFloat64(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle float8 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUInt8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle uint1 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUInt16(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle uint2 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteInt32(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle int4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteIntAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteIntAsString(IronPython.Runtime.CodeContext,System.Int32)">
            <summary>
            Write value in pickle decimalnl_short format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteLongAsString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle decimalnl_long format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUnicodeStringRaw(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle unicodestringnl format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteUnicodeStringUtf8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Write value in pickle unicodestring4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.WriteStringPair(IronPython.Runtime.CodeContext,System.Object,System.Object)">
            <summary>
            Write value in pickle stringnl_noescape_pair format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsUInt8(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle uint1 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsUInt16(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle uint2 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.IsInt32(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return true if value is appropriate for formatting in pickle int4 format.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchAppends(IronPython.Runtime.CodeContext,System.Collections.IEnumerator)">
            <summary>
            Emit a series of opcodes that will set append all items indexed by iter
            to the object at the top of the stack. Use APPENDS if possible, but
            append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchSetItems(IronPython.Runtime.CodeContext,IronPython.Runtime.PythonDictionary)">
            <summary>
            Emit a series of opcodes that will set all (key, value) pairs indexed by
            iter in the object at the top of the stack. Use SETITEMS if possible,
            but append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.BatchSetItems(IronPython.Runtime.CodeContext,System.Collections.IEnumerator)">
            <summary>
            Emit a series of opcodes that will set all (key, value) pairs indexed by
            iter in the object at the top of the stack. Use SETITEMS if possible,
            but append no more than BatchSize items at a time.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.PicklerObject.FindModuleForGlobal(IronPython.Runtime.CodeContext,System.Object,System.Object)">
            <summary>
            Find the module for obj and ensure that obj is reachable in that module by the given name.
            
            Throw PicklingError if any of the following are true:
             - The module couldn't be determined.
             - The module couldn't be loaded.
             - The given name doesn't exist in the module.
             - The given name is a different object than obj.
            
            Otherwise, return the name of the module.
            
            To determine which module obj lives in, obj.__module__ is used if available. The
            module named by obj.__module__ is loaded if needed. If obj has no __module__
            attribute, then each loaded module is searched. If a loaded module has an
            attribute with the given name, and that attribute is the same object as obj,
            then that module is used.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonPickle.UnpicklerObject.SetItems(IronPython.Runtime.PythonDictionary,System.Int32)">
            <summary>
            Interpret everything from markIndex to the top of the stack as a sequence
            of key, value, key, value, etc. Set dict[key] = value for each. Pop
            everything from markIndex up when done.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonDateTime.date.CheckType(System.Object,System.Boolean)">
            <summary>
            Used to check the type to see if we can do a comparison.  Returns true if we can
            or false if we should return NotImplemented.  May throw if the type's really wrong.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonDateTime.time.CompareTo(System.Object)">
            <summary>
            Helper function for doing the comparisons.  time has no __cmp__ method
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonIterTools.IterBase">
            <summary>
            Base class used for iterator wrappers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.erf(System.Double)">
            <summary>
            Error function on real values
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.erfc(System.Double)">
            <summary>
            Complementary error function on real values: erfc(x) =  1 - erf(x)
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.gamma(System.Double)">
            <summary>
            Gamma function on real values
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonMath.lgamma(System.Double)">
            <summary>
            Natural log of absolute value of Gamma function
            </summary>
        </member>
        <member name="T:IronPython.Modules.ModuleOps">
            <summary>
            Provides helper functions which need to be called from generated code to implement various 
            portions of modules.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.access(IronPython.Runtime.CodeContext,System.String,System.Int32)">
            <summary>
            Checks for the specific permissions, provided by the mode parameter, are available for the provided path.  Permissions can be:
            
            F_OK: Check to see if the file exists
            R_OK | W_OK | X_OK: Check for the specific permissions.  Only W_OK is respected.
            </summary>
        </member>
        <member name="F:IronPython.Modules.PythonNT.environ">
            <summary>
            single instance of environment dictionary is shared between multiple runtimes because the environment
            is shared by multiple runtimes.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.lstat(System.String)">
            <summary>
            lstat(path) -> stat result 
            Like stat(path), but do not follow symbolic links.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnl(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object[])">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnle(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object[])">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnv(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object)">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.spawnve(IronPython.Runtime.CodeContext,System.Int32,System.String,System.Object,System.Object)">
            <summary>
            spawns a new process.
            
            If mode is nt.P_WAIT then then the call blocks until the process exits and the return value
            is the exit code.
            
            Otherwise the call returns a handle to the process.  The caller must then call nt.waitpid(pid, options)
            to free the handle and get the exit code of the process.  Failure to call nt.waitpid will result
            in a handle leak.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.SetEnvironment(System.Collections.Specialized.StringDictionary,System.Object)">
            <summary>
            Copy elements from a Python mapping of dict environment variables to a StringDictionary.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonNT.ArgumentsToString(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Convert a sequence of args to a string suitable for using to spawn a process.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonRegex">
            <summary>
            Python regular expression module.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonRegex.RE_Pattern">
            <summary>
            Compiled reg-ex pattern
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonRegex.PreParseRegex(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Preparses a regular expression text returning a ParsedRegex class
            that can be used for further regular expressions.
            </summary>
        </member>
        <member name="T:IronPython.Modules.ResourceMetaPathImporter">
            <summary>
            Implementes a resource-based meta_path importer as described in PEP 302.
            </summary>
        </member>
        <member name="M:IronPython.Modules.ResourceMetaPathImporter.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Instantiates a new meta_path importer using an embedded ZIP resource file.
            </summary>
            <param name="fromAssembly"></param>
            <param name="resourceName"></param>
        </member>
        <member name="M:IronPython.Modules.PythonSelect.ProcessSocketSequence(IronPython.Runtime.CodeContext,System.Object,IronPython.Runtime.List@,System.Collections.Generic.Dictionary{System.Net.Sockets.Socket,System.Object}@)">
            <summary>
            Process a sequence of objects that are compatible with ObjectToSocket(). Return two
            things as out params: an in-order List of sockets that correspond to the original
            objects in the passed-in sequence, and a mapping of these socket objects to their
            original objects.
            
            The socketToOriginal mapping is generated because the CPython select module supports
            passing to select either file descriptor numbers or an object with a fileno() method.
            We try to be faithful to what was originally requested when we return.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSelect.ObjectToSocket(IronPython.Runtime.CodeContext,System.Object)">
            <summary>
            Return the System.Net.Sockets.Socket object that corresponds to the passed-in
            object. obj can be a System.Net.Sockets.Socket, a PythonSocket.SocketObj, a
            long integer (representing a socket handle), or a Python object with a fileno()
            method (whose result is used to look up an existing PythonSocket.SocketObj,
            which is in turn converted to a Socket.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonThread.interrupt_main(IronPython.Runtime.CodeContext)">
            <summary>
            Stops execution of Python or other .NET code on the main thread.  If the thread is
            blocked in native code the thread will be interrupted after it returns back to Python
            or other .NET code.  
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonThread._local.ThreadLocalDictionaryStorage">
            <summary>
            Provides a dictionary storage implementation whose storage is local to
            the thread.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonTime.FoundDateComponents">
            <summary>
            Represents the date components that we found while parsing the date.  Used for zeroing out values
            which have different defaults from CPython.  Currently we only know that we need to do this for
            the year.
            </summary>
        </member>
        <member name="T:IronPython.Modules.xxsubtype">
            <summary>
            Samples on how to subtype built-in types from C#
            </summary>
        </member>
        <member name="P:IronPython.Modules.xxsubtype.spamlist.state">
            <summary>
            an int variable for demonstration purposes
            </summary>
        </member>
        <member name="P:IronPython.Modules.xxsubtype.spamdict.state">
            <summary>
            an int variable for demonstration purposes
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonIOModule.BytesIO">
            <summary>
            BytesIO([initializer]) -> object
            
            Create a buffered I/O implementation using an in-memory bytes
            buffer, ready for reading and writing.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.BytesIO.close(IronPython.Runtime.CodeContext)">
            <summary>
            close() -> None.  Disable all I/O operations.
            </summary>
        </member>
        <member name="P:IronPython.Modules.PythonIOModule.BytesIO.closed">
            <summary>
            True if the file is closed.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.BytesIO.getvalue">
            <summary>
            getvalue() -> bytes.
            
            Retrieve the entire contents of the BytesIO object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.FileIO.StandardizeMode(System.String)">
            <summary>
            Remove all 'b's from mode string to simplify parsing
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.TextIOWrapper.ReadChunk(IronPython.Runtime.CodeContext)">
            <summary>
            Read and decode the next chunk from the buffered reader. Returns true if EOF was
            not reached. Places decoded string in _decodedChars.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.GetBytes(System.Object,System.String)">
            <summary>
            Convert string or bytes into bytes
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonIOModule.GetBytes(System.Object)">
            <summary>
            Convert most bytearray-like objects into IList of byte
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_build(System.String)">
            <summary>
            Creates an optimized encoding mapping that can be consumed by an optimized version of charmap_encode.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_encode(IronPython.Runtime.CodeContext,System.String,System.String,IronPython.Modules.EncodingMap)">
            <summary>
            Encodes the input string with the specified optimized encoding map.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCodecs.charmap_decode(IronPython.Runtime.CodeContext,System.String,System.String,System.String)">
            <summary>
            Decodes the input string using the provided string mapping.
            </summary>
        </member>
        <member name="T:IronPython.Modules.EncodingMap">
            <summary>
            Optimized encoding mapping that can be consumed by charmap_encode.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCollections.deque.WalkDeque(IronPython.Modules.PythonCollections.deque.DequeWalker)">
            <summary>
            Walks the queue calling back to the specified delegate for
            each populated index in the queue.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonCsvModule.GetDialects(IronPython.Runtime.CodeContext)">
            <summary>
            Returns the dialects from the code context.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:IronPython.Modules.CTypes">
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
            <summary>
            Provides support for interop with native code from Python code.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.ArrayType">
            <summary>
            The meta class for ctypes array instances.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.ArrayType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.CData">
            <summary>
            Base class for all ctypes interop types.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(IronPython.Runtime.PythonTuple)">
            <summary>
            Creates a new CFuncPtr object from a tuple.  The 1st element of the
            tuple is the ordinal or function name.  The second is an object with
            a _handle property.  The _handle property is the handle of the module
            from which the function will be loaded.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new CFuncPtr which calls a COM method.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Int32)">
            <summary>
            Creates a new CFuncPtr with the specfied address.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.#ctor(System.Numerics.BigInteger)">
            <summary>
            Creates a new CFuncPtr with the specfied address.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.AddKeepAlives(IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller[],System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            we need to keep alive any methods which have arguments for the duration of the
            call.  Otherwise they could be collected on the finalizer thread before we come back.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.CreateInteropInvoker(System.Runtime.InteropServices.CallingConvention,IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller[],IronPython.Modules.CTypes.INativeType,System.Boolean,System.Collections.Generic.List{System.Object})">
            <summary>
            Creates a method for calling with the specified signature.  The returned method has a signature
            of the form:
            
            (IntPtr funcAddress, arg0, arg1, ..., object[] constantPool)
            
            where IntPtr is the address of the function to be called.  The arguments types are based upon
            the types that the ArgumentMarshaller requires.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller">
            <summary>
            Base class for marshalling arguments from the user provided value to the
            call stub.  This class provides the logic for creating the call stub and
            calling it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.EmitCallStubArgument(System.Reflection.Emit.ILGenerator,System.Int32,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits the IL to get the argument for the call stub generated into
            a dynamic method.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.ArgumentExpression">
            <summary>
            Gets the expression used to provide the argument.  This is the expression
            from an incoming DynamicMetaObject.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes._CFuncPtr.Meta.ArgumentMarshaller.GetKeepAlive">
            <summary>
            Gets an expression which keeps alive the argument for the duration of the call.  
            
            Returns null if a keep alive is not necessary.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.PrimitiveMarshaller">
            <summary>
            Provides marshalling of primitive values when the function type
            has no type information or when the user has provided us with
            an explicit cdata instance.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.CDataMarshaller">
            <summary>
            Provides marshalling for when the function type provide argument information.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._CFuncPtr.Meta.NativeArgumentMarshaller">
            <summary>
            Provides marshalling for when the user provides a native argument object
            (usually gotten by byref or pointer) and the function type has no type information.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.CFuncPtrType">
            <summary>
            The meta class for ctypes function pointer instances.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.CFuncPtrType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.Field">
            <summary>
            Fields are created when a Structure is defined and provide
            introspection of the structure.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Field.ExtractBits(System.Object)">
            <summary>
            Called for fields which have been limited to a range of bits.  Given the
            value for the full type this extracts the individual bits.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Field.SetBitsValue(IronPython.Modules.MemoryHolder,System.Int32,System.Object)">
            <summary>
            Called for fields which have been limited to a range of bits.  Sets the 
            specified value into the bits for the field.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.INativeType">
            <summary>
            Common functionality that all of the meta classes provide which is part of
            our implementation.  This is used to implement the serialization/deserialization
            of values into/out of memory, emit the marshalling logic for call stubs, and
            provide common information (size/alignment) for the types.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.Size">
            <summary>
            Gets the native size of the type
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.Alignment">
            <summary>
            Gets the required alignment for the type
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetValue(IronPython.Modules.MemoryHolder,System.Object,System.Int32,System.Boolean)">
            <summary>
            Deserialized the value of this type from the given address at the given
            offset.  Any new objects which are created will keep the provided 
            MemoryHolder alive.
            
            raw determines if the cdata is returned or if the primitive value is
            returned.  This is only applicable for subtypes of simple cdata types.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.SetValue(IronPython.Modules.MemoryHolder,System.Int32,System.Object)">
            <summary>
            Serializes the provided value into the specified address at the given
            offset.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetNativeType">
            <summary>
            Gets the .NET type which is used when calling or returning the value
            from native code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.GetPythonType">
            <summary>
            Gets the .NET type which the native type is converted into when going to Python
            code.  This is usually int, BigInt, double, object, or a CData type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.EmitMarshalling(System.Reflection.Emit.ILGenerator,IronPython.Modules.LocalOrArg,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits marshalling of an object from Python to native code.  This produces the
            native type from the Python type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.INativeType.EmitReverseMarshalling(System.Reflection.Emit.ILGenerator,IronPython.Modules.LocalOrArg,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits marshalling from native code to Python code This produces the python type 
            from the native type.  This is used for return values and parameters 
            to Python callable objects that are passed back out to native code.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.INativeType.TypeFormat">
            <summary>
            Returns a string which describes the type.  Used for _buffer_info implementation which
            only exists for testing purposes.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.PointerType">
            <summary>
            The meta class for ctypes pointers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PointerType.from_param(IronPython.Modules.CTypes.Pointer)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PointerType.from_address(System.Object)">
            <summary>
            Access an instance at the specified address
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.SimpleType">
            <summary>
            The meta class for ctypes simple data types.  These include primitives like ints,
            floats, etc... char/wchar pointers, and untyped pointers.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.SimpleType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.SimpleType.ReadChar(IronPython.Modules.MemoryHolder,System.Int32)">
            <summary>
            Helper function for reading char/wchar's.  This is used for reading from
            arrays and pointers to avoid creating lots of 1-char strings.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.SimpleTypeKind">
            <summary>
            The enum used for tracking the various ctypes primitive types.
            </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Char">
            <summary> 'c' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedByte">
            <summary> 'b' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedByte">
            <summary> 'B' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedShort">
            <summary> 'h' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedShort">
            <summary> 'H' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedInt">
            <summary> 'i' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedInt">
            <summary> 'I' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedLong">
            <summary> 'l' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedLong">
            <summary> 'L' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Single">
            <summary> 'f' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Double">
            <summary> 'd', 'g' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.SignedLongLong">
            <summary> 'q' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.UnsignedLongLong">
            <summary> 'Q' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Object">
            <summary> 'O' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Pointer">
            <summary> 'P' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.CharPointer">
            <summary> 'z' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.WCharPointer">
            <summary> 'Z' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.WChar">
            <summary> 'u' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.Boolean">
            <summary> '?' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.VariantBool">
            <summary> 'v' </summary>
        </member>
        <member name="F:IronPython.Modules.CTypes.SimpleTypeKind.BStr">
            <summary> 'X' </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.StructType">
            <summary>
            Meta class for structures.  Validates _fields_ on creation, provides factory
            methods for creating instances from addresses and translating to parameters.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StructType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            
            Structures just return themselves.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StructType.EnsureSizeAndAlignment">
            <summary>
            If our size/alignment hasn't been initialized then grabs the size/alignment
            from all of our base classes.  If later new _fields_ are added we'll be
            initialized and these values will be replaced.
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes._Structure">
            <summary>
            Base class for data structures.  Subclasses can define _fields_ which 
            specifies the in memory layout of the values.  Instances can then
            be created with the initial values provided as the array.  The values
            can then be accessed from the instance by field name.  The value can also
            be passed to a foreign C API and the type can be used in other structures.
            
            class MyStructure(Structure):
                _fields_ = [('a', c_int), ('b', c_int)]
                
            MyStructure(1, 2).a
            MyStructure()
            
            class MyOtherStructure(Structure):
                _fields_ = [('c', MyStructure), ('b', c_int)]
                
            MyOtherStructure((1, 2), 3)
            MyOtherStructure(MyStructure(1, 2), 3)
            </summary>
        </member>
        <member name="T:IronPython.Modules.CTypes.UnionType">
            <summary>
            The meta class for ctypes unions.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.UnionType.from_param(System.Object)">
            <summary>
            Converts an object into a function call parameter.
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes._cast_addr">
            <summary>
            Gets a function which casts the specified memory.  Because this is used only
            w/ Python API we use a delegate as the return type instead of an actual address.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Cast(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Implementation of our cast function.  data is marshalled as a void*
            so it ends up as an address.  obj and type are marshalled as an object
            so we need to unmarshal them.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.POINTER(IronPython.Runtime.CodeContext,IronPython.Runtime.Types.PythonType)">
            <summary>
            Returns a new type which represents a pointer given the existing type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PyObj_FromPtr(System.IntPtr)">
            <summary>
            Converts an address acquired from PyObj_FromPtr or that has been
            marshaled as type 'O' back into an object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.PyObj_ToPtr(System.Object)">
            <summary>
            Converts an object into an opaque address which can be handed out to
            managed code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Py_DECREF(System.Object)">
            <summary>
            Decreases the ref count on an object which has been increased with
            Py_INCREF.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.Py_INCREF(System.Object)">
            <summary>
            Increases the ref count on an object ensuring that it will not be collected.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.addressof(IronPython.Modules.CTypes.CData)">
            <summary>
            returns address of C instance internal buffer.
            
            It is the callers responsibility to ensure that the provided instance will 
            stay alive if memory in the resulting address is to be used later.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.alignment(IronPython.Runtime.Types.PythonType)">
            <summary>
            Gets the required alignment of the given type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.alignment(System.Object)">
            <summary>
            Gets the required alignment of an object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.pointer(IronPython.Runtime.CodeContext,IronPython.Modules.CTypes.CData)">
            <summary>
            Returns a pointer instance for the given CData
            </summary>
        </member>
        <member name="P:IronPython.Modules.CTypes.DynamicModule">
            <summary>
            Gets the ModuleBuilder used to generate our unsafe call stubs into.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetMarshalTypeFromSize(System.Int32)">
            <summary>
            Given a specific size returns a .NET type of the equivalent size that
            we can use when marshalling these values across calls.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetFieldInfo(IronPython.Modules.CTypes.INativeType,System.Object,System.String@,IronPython.Modules.CTypes.INativeType@,System.Nullable{System.Int32}@)">
            <summary>
            Shared helper between struct and union for getting field info and validating it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.CheckBits(IronPython.Modules.CTypes.INativeType,IronPython.Runtime.PythonTuple)">
            <summary>
            Verifies that the provided bit field settings are valid for this type.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.GetFieldsList(System.Object)">
            <summary>
            Shared helper to get the _fields_ list for struct/union and validate it.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.StringAt(System.IntPtr,System.Int32)">
            <summary>
            Helper function for translating from memset to NT's FillMemory API.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.WStringAt(System.IntPtr,System.Int32)">
            <summary>
            Helper function for translating from memset to NT's FillMemory API.
            </summary>
        </member>
        <member name="M:IronPython.Modules.CTypes.EmitCDataCreation(IronPython.Modules.CTypes.INativeType,System.Reflection.Emit.ILGenerator,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Emits the marshalling code to create a CData object for reverse marshalling.
            </summary>
        </member>
        <member name="T:IronPython.Modules.LocalOrArg">
            <summary>
            Wrapper class for emitting locals/variables during marshalling code gen.
            </summary>
        </member>
        <member name="T:IronPython.Modules.MemoryHolder">
            <summary>
            A wrapper around allocated memory to ensure it gets released and isn't accessed
            when it could be finalized.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.Int32)">
            <summary>
            Creates a new MemoryHolder and allocates a buffer of the specified size.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Creates a new MemoryHolder at the specified address which is not tracked
            by us and we will never free.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.#ctor(System.IntPtr,System.Int32,IronPython.Modules.MemoryHolder)">
            <summary>
            Creates a new MemoryHolder at the specified address which will keep alive the 
            parent memory holder.
            </summary>
        </member>
        <member name="P:IronPython.Modules.MemoryHolder.UnsafeAddress">
            <summary>
            Gets the address of the held memory.  The caller should ensure the MemoryHolder
            is always alive as long as the address will continue to be accessed.
            </summary>
        </member>
        <member name="P:IronPython.Modules.MemoryHolder.Objects">
            <summary>
            Gets a list of objects which need to be kept alive for this MemoryHolder to be 
            remain valid.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.AddObject(System.Object,System.Object)">
            <summary>
            Used to track the lifetime of objects when one memory region depends upon
            another memory region.  For example if you have an array of objects that
            each have an element which has it's own lifetime the array needs to keep
            the individual elements alive.
            
            The keys used here match CPython's keys as tested by CPython's test_ctypes. 
            Typically they are a string which is the array index, "ffffffff" when
            from_buffer is used, or when it's a simple type there's just a string
            instead of the full dictionary - we store that under the key "str".
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.CopyFrom(System.IntPtr,System.IntPtr)">
            <summary>
            Copies the data in data into this MemoryHolder.
            </summary>
        </member>
        <member name="M:IronPython.Modules.MemoryHolder.CopyTo(IronPython.Modules.MemoryHolder,System.Int32,System.Int32)">
            <summary>
            Copies memory from one location to another keeping the associated memory holders alive during the
            operation.
            </summary>
        </member>
        <member name="T:IronPython.Modules.NativeFunctions">
            <summary>
            Native functions used for exposing ctypes functionality.
            </summary>
        </member>
        <member name="M:IronPython.Modules.NativeFunctions.Calloc(System.IntPtr)">
            <summary>
            Allocates memory that's zero-filled
            </summary>
        </member>
        <member name="M:IronPython.Modules.NativeFunctions.MemSet(System.IntPtr,System.Byte,System.IntPtr)">
            <summary>
            Helper function for implementing memset.  Could be more efficient if we 
            could P/Invoke or call some otherwise native code to do this.
            </summary>
        </member>
        <member name="T:IronPython.Modules.FunctionTools.partial">
            <summary>
            Returns a new callable object with the provided initial set of arguments
            bound to it.  Calling the new function then appends to the additional
            user provided arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.#ctor(IronPython.Runtime.CodeContext,System.Object,System.Object[])">
            <summary>
            Creates a new partial object with the provided positional arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.#ctor(IronPython.Runtime.CodeContext,System.Object,System.Collections.Generic.IDictionary{System.Object,System.Object},System.Object[])">
            <summary>
            Creates a new partial object with the provided positional and keyword arguments.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.func">
            <summary>
            Gets the function which will be called
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.args">
            <summary>
            Gets the initially provided positional arguments.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.keywords">
            <summary>
            Gets the initially provided keyword arguments or None.
            </summary>
        </member>
        <member name="P:IronPython.Modules.FunctionTools.partial.__dict__">
            <summary>
            Gets or sets the dictionary used for storing extra attributes on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.Call(IronPython.Runtime.CodeContext,System.Object[])">
            <summary>
            Calls func with the previously provided arguments and more positional arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.Call(IronPython.Runtime.CodeContext,System.Collections.Generic.IDictionary{System.Object,System.Object},System.Object[])">
            <summary>
            Calls func with the previously provided arguments and more positional arguments and keyword arguments.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.SetMemberAfter(IronPython.Runtime.CodeContext,System.String,System.Object)">
            <summary>
            Operator method to set arbitrary members on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.GetBoundMember(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Operator method to get additional arbitrary members defined on the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.FunctionTools.partial.DeleteMember(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Operator method to delete arbitrary members defined in the partial object.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonLocale.LocaleInfo.CreateConventionsDict">
            <summary>
            Populates the given directory w/ the locale information from the given
            CultureInfo.
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonRandom.RandomGen">
            <summary>
            Generator based on the .NET Core implementation of System.Random
            </summary>
        </member>
        <member name="F:IronPython.Modules.PythonSocket.socket._handleToSocket">
            <summary>
            handleToSocket allows us to translate from Python's idea of a socket resource (file
            descriptor numbers) to .NET's idea of a socket resource (System.Net.Socket objects).
            In particular, this allows the select module to convert file numbers (as returned by
            fileno()) and convert them to Socket objects so that it can do something useful with them.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.HandleToSocket(System.Int64)">
            <summary>
            Return the internal System.Net.Sockets.Socket socket object associated with the given
            handle (as returned by GetHandle()), or null if no corresponding socket exists. This is
            primarily intended to be used by other modules (such as select) that implement
            networking primitives. User code should not normally need to call this function.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.#ctor(IronPython.Runtime.CodeContext,System.Net.Sockets.Socket)">
            <summary>
            Create a Python socket object from an existing .NET socket object
            (like one returned from Socket.Accept())
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.socket.Initialize(IronPython.Runtime.CodeContext,System.Net.Sockets.Socket)">
            <summary>
            Perform initialization common to all constructors
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.SignInsensitiveToInt32(System.Object)">
            <summary>
            Convert an object to a 32-bit integer. This adds two features to Converter.ToInt32:
              1. Sign is ignored. For example, 0xffff0000 converts to 4294901760, where Convert.ToInt32
                 would throw because 0xffff0000 is less than zero.
              2. Overflow exceptions are thrown. Converter.ToInt32 throws TypeError if x is
                 an integer, but is bigger than 32 bits. Instead, we throw OverflowException.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.SignInsensitiveToInt16(System.Object)">
            <summary>
            Convert an object to a 16-bit integer. This adds two features to Converter.ToInt16:
              1. Sign is ignored. For example, 0xff00 converts to 65280, where Convert.ToInt16
                 would throw because signed 0xff00 is -256.
              2. Overflow exceptions are thrown. Converter.ToInt16 throws TypeError if x is
                 an integer, but is bigger than 16 bits. Instead, we throw OverflowException.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.MakeException(IronPython.Runtime.CodeContext,System.Exception)">
            <summary>
            Return a standard socket exception (socket.error) whose message and error code come from a SocketException
            This will eventually be enhanced to generate the correct error type (error, herror, gaierror) based on the error code.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.IPv6BytesToColonHex(System.Byte[])">
            <summary>
            Convert an IPv6 address byte array to a string in standard colon-hex notation.
            The .NET IPAddress.ToString() method uses dotted-quad for the last 32 bits,
            which differs from the normal Python implementation (but is allowed by the IETF);
            this method returns the standard (no dotted-quad) colon-hex form.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.ConvertSpecialAddresses(System.String)">
            <summary>
            Handle conversion of "" to INADDR_ANY and "&lt;broadcast&gt;" to INADDR_BROADCAST.
            Otherwise returns host unchanged.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.HostToAddress(IronPython.Runtime.CodeContext,System.String,System.Net.Sockets.AddressFamily)">
            <summary>
            Return the IP address associated with host, with optional address family checking.
            host may be either a name or an IP address (in string form).
            
            If family is non-null, a gaierror will be thrown if the host's address family is
            not the same as the specified family. gaierror is also raised if the hostname cannot be
            converted to an IP address (e.g. through a name lookup failure).
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.HostToAddresses(IronPython.Runtime.CodeContext,System.String,System.Net.Sockets.AddressFamily)">
            <summary>
            Return the IP address associated with host, with optional address family checking.
            host may be either a name or an IP address (in string form).
            
            If family is non-null, a gaierror will be thrown if the host's address family is
            not the same as the specified family. gaierror is also raised if the hostname cannot be
            converted to an IP address (e.g. through a name lookup failure).
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.RemoveLocalDomain(System.String)">
            <summary>
            Return fqdn, but with its domain removed if it's on the same domain as the local machine.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.TupleToEndPoint(IronPython.Runtime.CodeContext,IronPython.Runtime.PythonTuple,System.Net.Sockets.AddressFamily,System.String@)">
            <summary>
            Convert a (host, port) tuple [IPv4] (host, port, flowinfo, scopeid) tuple [IPv6]
            to its corresponding IPEndPoint.
            
            Throws gaierror if host is not a valid address.
            Throws ArgumentTypeException if any of the following are true:
             - address does not have exactly two elements
             - address[0] is not a string
             - address[1] is not an int
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSocket.EndPointToTuple(System.Net.IPEndPoint)">
            <summary>
            Convert an IPEndPoint to its corresponding (host, port) [IPv4] or (host, port, flowinfo, scopeid) [IPv6] tuple.
            Throws SocketException if the address family is other than IPv4 or IPv6.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSsl.ReadInt(System.Byte[],System.Int32@)">
            <summary>
            BER encoding of an integer value is the number of bytes
            required to represent the integer followed by the bytes
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonStruct.FormatType">
            <summary>
            Enum which specifies the format type for a compiled struct
            </summary>
        </member>
        <member name="T:IronPython.Modules.PythonStruct.Format">
            <summary>
            Struct used to store the format and the number of times it should be repeated.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonSubprocess.DuplicateHandle(IronPython.Runtime.CodeContext,System.Numerics.BigInteger,IronPython.Modules.PythonSubprocessHandle,System.Numerics.BigInteger,System.Int32,System.Boolean,System.Object)">
            <summary>
            Duplicates a subprocess handle which was created for piping.
            
            This is only called when we're duplicating the handle to make it inheritable to the child process.  In CPython
            the parent handle is always reliably garbage collected.  Because we know this handle is not going to be 
            used we close the handle being duplicated.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.ConvertToWeakReferenceable(IronPython.Runtime.PythonContext,System.Object)">
            <summary>
            Wrapper provided for backwards compatibility.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.ref.__hash__(IronPython.Runtime.CodeContext)">
            <summary>
            Special hash function because IStructuralEquatable.GetHashCode is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.ref.RefEquals(System.Object,System.Object,System.Collections.IEqualityComparer)">
            <summary>
            Special equals because none of the special cases in Ops.Equals
            are applicable here, and the reference equality check breaks some tests.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakproxy.GetObject">
            <summary>
            gets the object or throws a reference exception
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakproxy.__eq__(System.Object)">
            <summary>
            Special equality function because IStructuralEquatable.Equals is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakcallableproxy.GetObject">
            <summary>
            gets the object or throws a reference exception
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWeakRef.weakcallableproxy.__eq__(System.Object)">
            <summary>
            Special equality function because IStructuralEquatable.Equals is not allowed to throw.
            </summary>
        </member>
        <member name="M:IronPython.Modules.PythonWinReg.HKEYType.GetKey">
            <summary>
            Returns the underlying .NET RegistryKey
            </summary>
            <returns></returns>
        </member>
        <member name="F:IronPython.Runtime.ZipImportModule.zipimporter._search_order">
            <summary>
            zip_searchorder defines how we search for a module in the Zip
            archive: we first search for a package __init__, then for
            non-package .pyc, .pyo and .py entries. The .pyc and .pyo entries
            are swapped by initzipimport() if we run in optimized mode. Also,
            '/' is replaced by SEP there.
            </summary>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetData(IronPython.Runtime.CodeContext,System.String,IronPython.Runtime.PythonTuple)">
            <summary>
            Given a path to a Zip file and a toc_entry, return the (uncompressed)
            data as a new reference.
            </summary>
            <param name="archive"></param>
            <param name="toc_entry"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetCodeFromData(IronPython.Runtime.CodeContext,System.Boolean,System.Boolean,System.Int32,IronPython.Runtime.PythonTuple)">
            <summary>
            Return the code object for the module named by 'fullname' from the
            Zip archive as a new reference.
            </summary>
            <param name="context"></param>
            <param name="ispackage"></param>
            <param name="isbytecode"></param>
            <param name="mtime"></param>
            <param name="toc_entry"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.ReadDirectory(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Given a path to a Zip archive, build a dict, mapping file names
            (local to the archive, using SEP as a separator) to toc entries.
            
            A toc_entry is a tuple:
            (__file__,      # value to use for __file__, available for all files
             compress,      # compression kind; 0 for uncompressed
             data_size,     # size of compressed data on disk
             file_size,     # size of decompressed data
             file_offset,   # offset of file header from start of archive
             time,          # mod time of file (in dos format)
             date,          # mod data of file (in dos format)
             crc,           # crc checksum of the data
             )
            Directories can be recognized by the trailing SEP in the name,
            data_size and file_offset are 0.
            </summary>
            <param name="archive"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.MakeFilename(IronPython.Runtime.CodeContext,System.String,System.String)">
            <summary>
            Given a (sub)modulename, write the potential file path in the
            archive (without extension) to the path buffer. 
            </summary>
            <param name="prefix"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:IronPython.Runtime.ZipImportModule.zipimporter.GetModuleInfo(IronPython.Runtime.CodeContext,System.String)">
            <summary>
            Determines the type of module we have (package or module, or not found).
            </summary>
            <param name="context"></param>
            <param name="fullname"></param>
            <returns></returns>
        </member>
        <member name="T:IronPython.Runtime.ZipImportModule.MemoryStreamContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BitWriter.RemainingBits">
            <summary>
              Delivers the remaining bits, left-aligned, in a byte.
            </summary>
            <remarks>
              <para>
                This is valid only if NumRemainingBits is less than 8;
                in other words it is valid only after a call to Flush().
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Reset">
            <summary>
              Reset the BitWriter.
            </summary>
            <remarks>
              <para>
                This is useful when the BitWriter writes into a MemoryStream, and
                is used by a BZip2Compressor, which itself is re-used for multiple
                distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteBits(System.Int32,System.UInt32)">
            <summary>
              Write some number of bits from the given value, into the output.
            </summary>
            <remarks>
              <para>
                The nbits value should be a max of 25, for safety. For performance
                reasons, this method does not check!
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteByte(System.Byte)">
            <summary>
              Write a full 8-bit byte into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteInt(System.UInt32)">
            <summary>
              Write four 8-bit bytes into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Flush">
            <summary>
              Write all available byte-aligned bytes.
            </summary>
            <remarks>
              <para>
                This method writes no new output, but flushes any accumulated
                bits. At completion, the accumulator may contain up to 7
                bits.
              </para>
              <para>
                This is necessary when re-assembling output from N independent
                compressors, one for each of N blocks. The output of any
                particular compressor will in general have some fragment of a byte
                remaining. This fragment needs to be accumulated into the
                parent BZip2OutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.FinishAndPad">
            <summary>
              Writes all available bytes, and emits padding for the final byte as
              necessary. This must be the last method invoked on an instance of
              BitWriter.
            </summary>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.increments">
            Knuth's increments seem to work better than Incerpi-Sedgewick here.
            Possibly because the number of elems to sort is usually small, typically
            &lt;= 20.
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.#ctor(Ionic.BZip2.BitWriter)">
            <summary>
              BZip2Compressor writes its compressed data out via a BitWriter. This
              is necessary because BZip2 does byte shredding.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2Compressor.UncompressedBytes">
            <summary>
              The number of uncompressed bytes being held in the buffer.
            </summary>
            <remarks>
              <para>
                I am thinking this may be useful in a Stream that uses this
                compressor class. In the Close() method on the stream it could
                check this value to see if anything has been written at all.  You
                may think the stream could easily track the number of bytes it
                wrote, which would eliminate the need for this. But, there is the
                case where the stream writes a complete block, and it is full, and
                then writes no more. In that case the stream may want to check.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.Fill(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Accept new bytes into the compressor data buffer
            </summary>
            <remarks>
              <para>
                This method does the first-level (cheap) run-length encoding, and
                stores the encoded data into the rle block.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.write0(System.Byte)">
             <summary>
               Process one input byte into the block.
             </summary>
            
             <remarks>
               <para>
                 To "process" the byte means to do the run-length encoding.
                 There are 3 possible return values:
            
                    0 - the byte was not written, in other words, not
                        encoded into the block. This happens when the
                        byte b would require the start of a new run, and
                        the block has no more room for new runs.
            
                    1 - the byte was written, and the block is not full.
            
                    2 - the byte was written, and the block is full.
            
               </para>
             </remarks>
             <returns>0 if the byte was not written, non-zero if written.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.AddRunToOutputBlock(System.Boolean)">
             <summary>
               Append one run to the output block.
             </summary>
            
             <remarks>
               <para>
                 This compressor does run-length-encoding before BWT and etc. This
                 method simply appends a run to the output block. The append always
                 succeeds. The return value indicates whether the block is full:
                 false (not full) implies that at least one additional run could be
                 processed.
               </para>
             </remarks>
             <returns>true if the block is now full; otherwise false.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.CompressAndWrite">
            <summary>
              Compress the data that has been placed (Run-length-encoded) into the
              block. The compressed data goes into the CompressedBytes array.
            </summary>
            <remarks>
              <para>
                Side effects: 1.  fills the CompressedBytes array.  2. sets the
                AvailableBytesOut property.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainSimpleSort(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
             This is the most hammered method of this class.
            
             <p>
             This is the version using unrolled loops.
             </p>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainQSort3(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
            Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.CompressionState.quadrant">
            Array instance identical to sfmap, both are used only
            temporarily and independently, so we do not need to allocate
            additional memory.
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream">
            <summary>
              A read-only decorator stream that performs BZip2 decompression on Read.
            </summary>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream.CState">
            <summary>
              Compressor State
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
            <summary>
              Create a BZip2InputStream, wrapping it around the given input Stream.
            </summary>
            <remarks>
              <para>
                The input stream will be closed when the BZip2InputStream is closed.
              </para>
            </remarks>
            <param name='input'>The stream from which to read compressed data</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a BZip2InputStream with the given stream, and
               specifying whether to leave the wrapped stream open when
               the BZip2InputStream is closed.
             </summary>
             <param name='input'>The stream from which to read compressed data</param>
             <param name='leaveOpen'>
               Whether to leave the input stream open, when the BZip2InputStream closes.
             </param>
            
             <example>
            
               This example reads a bzip2-compressed file, decompresses it,
               and writes the decompressed data into a newly created file.
            
               <code>
               var fname = "logfile.log.bz2";
               using (var fs = File.OpenRead(fname))
               {
                   using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
                   {
                       var outFname = fname + ".decompressed";
                       using (var output = File.Create(outFname))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = decompressor.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               output.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read data from the stream.
             </summary>
            
             <remarks>
               <para>
                 To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
                 providing a stream that reads compressed data.  Then call Read() on
                 that <c>BZip2InputStream</c>, and the data read will be decompressed
                 as you read.
               </para>
            
               <para>
                 A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
               </para>
             </remarks>
            
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.ReadByte">
            <summary>
              Read a single byte from the stream.
            </summary>
            <returns>the byte read from the stream, or -1 if EOF</returns>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes read in.
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name='buffer'>this parameter is never used</param>
            <param name='offset'>this parameter is never used</param>
            <param name='count'>this parameter is never used</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.GetBits(System.Int32)">
            <summary>
              Read n bits from input, right justifying the result.
            </summary>
            <remarks>
              <para>
                For example, if you read 1 bit, the result is either 0
                or 1.
              </para>
            </remarks>
            <param name ="n">
              The number of bits to read, always between 1 and 32.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.hbCreateDecodeTables(System.Int32[],System.Int32[],System.Int32[],System.Char[],System.Int32,System.Int32,System.Int32)">
            Called by createHuffmanDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.createHuffmanDecodingTables(System.Int32,System.Int32)">
            Called by recvDecodingTables() exclusively.
        </member>
        <member name="F:Ionic.BZip2.BZip2InputStream.DecompressionState.unzftab">
            Freq table collected to save a pass over the data during
            decompression.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DecompressionState.initTT(System.Int32)">
             Initializes the tt array.
            
             This method is called when the required length of the array is known.
             I don't initialize it at construction time to avoid unneccessary
             memory allocation when compressing small files.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DumpState">
            <summary>
            Dump the current state of the decompressor, to restore it in case of an error.
            This allows the decompressor to be essentially "rewound" and retried when more
            data arrives.
            
            This is only used by IronPython.
            </summary>
            <returns>The current state.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.RestoreState(System.Object)">
            <summary>
            Restore the internal compressor state if an error occurred.
            </summary>
            <param name="o">The old state.</param>
        </member>
        <member name="T:Ionic.BZip2.BZip2OutputStream">
            <summary>
              A write-only decorator stream that compresses data as it is
              written using the BZip2 algorithm.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.BZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>BZip2OutputStream</c> to compress data while writing:
               create a <c>BZip2OutputStream</c> with a writable output stream.
               Then call <c>Write()</c> on that <c>BZip2OutputStream</c>, providing
               uncompressed data as input.  The data sent to the output stream will
               be the compressed form of the input data.
             </para>
            
             <para>
               A <c>BZip2OutputStream</c> can be used only for <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value should always be true, unless and until the
            object is disposed and closed.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name='buffer'>this parameter is never used</param>
            <param name='offset'>this parameter is never used</param>
            <param name='count'>this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="T:Ionic.BZip2.ParallelBZip2OutputStream">
             <summary>
               A write-only decorator stream that compresses data as it is
               written using the BZip2 algorithm. This stream compresses by
               block using multiple threads.
             </summary>
             <para>
               This class performs BZIP2 compression through writing.  For
               more information on the BZIP2 algorithm, see
               <see href="http://en.wikipedia.org/wiki/BZIP2"/>.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.BZip2.BZip2OutputStream"/>,
               except that this implementation uses an approach that employs multiple
               worker threads to perform the compression.  On a multi-cpu or multi-core
               computer, the performance of this class can be significantly higher than
               the single-threaded BZip2OutputStream, particularly for larger streams.
               How large?  Anything over 10mb is a good candidate for parallel
               compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla <c>BZip2OutputStream</c>. Also, for small files, the
               <c>ParallelBZip2OutputStream</c> can be much slower than the vanilla
               <c>BZip2OutputStream</c>, because of the overhead associated to using the
               thread pool.
             </para>
            
             <seealso cref="T:Ionic.BZip2.BZip2OutputStream" />
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.ParallelBZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.MaxWorkers">
             <summary>
               The maximum number of concurrent compression worker threads to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of concurrent worker
               threads to employ for compression. The implementation of this stream
               employs multiple threads from the .NET thread pool, via 
               ThreadPool.QueueUserWorkItem(), to compress the incoming data by
               block.  As each block of data is compressed, this stream re-orders the
               compressed blocks and writes them to the output stream.
             </para>
            
             <para>
               A higher number of workers enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               By default, DotNetZip allocates 4 workers per CPU core, subject to the
               upper limit specified in this property. For example, suppose the
               application sets this property to 16.  Then, on a machine with 2
               cores, DotNetZip will use 8 workers; that number does not exceed the
               upper limit specified by this property, so the actual number of
               workers used will be 4 * 2 = 8.  On a machine with 4 cores, DotNetZip
               will use 16 workers; again, the limit does not apply. On a machine
               with 8 cores, DotNetZip will use 16 workers, because of the limit.
             </para>
            
             <para>
               For each compression "worker thread" that occurs in parallel, there is
               up to 2mb of memory allocated, for buffering and processing. The
               actual number depends on the <see cref="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize"/> property.
             </para>
            
             <para>
               CPU utilization will also go up with additional workers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>ParallelBZip2OutputStream</c> to compress data while
               writing: create a <c>ParallelBZip2OutputStream</c> with a writable
               output stream.  Then call <c>Write()</c> on that
               <c>ParallelBZip2OutputStream</c>, providing uncompressed data as
               input.  The data sent to the output stream will be the compressed
               form of the input data.
             </para>
            
             <para>
               A <c>ParallelBZip2OutputStream</c> can be used only for
               <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BytesWrittenOut">
            <summary>
            The total number of bytes written out by the stream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name='buffer'>this parameter is never used</param>
            <param name='offset'>this parameter is never used</param>
            <param name='count'>this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="M:Ionic.BZip2.Rand.Rnums(System.Int32)">
            <summary>
              Returns the "random" number at a specific index.
            </summary>
            <param name='i'>the index</param>
            <returns>the random number</returns>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="!:Close()"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
    </members>
</doc>
